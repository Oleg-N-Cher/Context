From: <Saved by Blink>
Snapshot-Content-Location: https://www.avhohlov.narod.ru/p1820en.htm
Subject: Yet another simple compiler for CP/M-80
Date: Sat, 20 Apr 2024 04:05:03 +0300
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--tPmwumyDLue6sGvbnBmHxGouL6wPfBB98PVhjOoSiw----"


------MultipartBoundary--tPmwumyDLue6sGvbnBmHxGouL6wPfBB98PVhjOoSiw----
Content-Type: text/html
Content-ID: <frame-A45D9983522DE29A7E61FA154EE0BDAF@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://www.avhohlov.narod.ru/p1820en.htm

<html><head><meta http-equiv=3D"Content-Type" content=3D"text/html; charset=
=3DUTF-8">
=09
=09


<title>
Yet another simple compiler for CP/M-80
</title>
</head>
<body>
<table border=3D"0"><tbody><tr><td valign=3D"TOP"><b><font color=3D"BLUE">A=
ndrei&nbsp;<br>Khokhlov&nbsp;<br>homepage&nbsp;<br></font></b></td><td vali=
gn=3D"TOP"><a href=3D"https://www.avhohlov.narod.ru/engl010.htm"><nobr>Home=
</nobr></a></td><td valign=3D"TOP">|</td><td valign=3D"TOP"><a href=3D"http=
s://www.avhohlov.narod.ru/p0010en.htm"><nobr>Site map</nobr></a></td><td va=
lign=3D"TOP">|</td><td valign=3D"TOP"><a href=3D"https://www.avhohlov.narod=
.ru/p9800en.htm"><nobr>Context Language</nobr></a></td><td valign=3D"TOP">|=
</td><td valign=3D"TOP"><a href=3D"https://www.avhohlov.narod.ru/p9900en.ht=
m"><nobr>Links</nobr></a></td><td valign=3D"TOP">|</td><td valign=3D"TOP"><=
a href=3D"http://www.narod.ru/guestbook/?owner=3D85596"><nobr>Guest book</n=
obr></a></td><td valign=3D"TOP">|</td><td valign=3D"TOP"><a href=3D"https:/=
/www.avhohlov.narod.ru/p9990en.htm"><nobr>Author</nobr></a></td><td valign=
=3D"TOP">|</td><td valign=3D"TOP"><form name=3D"LangForm" method=3D"GET"><s=
elect name=3D"LangSel"><option value=3D"" selected=3D"">Language</option><o=
ption value=3D"en">English</option><option value=3D"ru">Russian</option></s=
elect></form></td></tr></tbody></table><hr>
<center><h3>Yet another simple compiler for CP/M-80</h3></center>
<p>
There are two sources - cross compiler (host - DOS, target - CP/M)
and self compiler (host and target - CP/M). Compiled program must
be placed in file with name C.PRG, compiled result are saved
in file C.COM. CP/M version was tested in MYZ80 1.24 CP/M emulator.
</p><p>
</p><xmp>
  char  Text  [16384];
  word pText;
  word nText;
  word nLine;

  byte  Code  [16384];
  word nCode;

  word hFile;

  char  Heap  [ 2048];
  word nHeap;

  word  Name  [  144];
  word  Cls   [  144];
  word  Sub   [  144];
  word  Type  [  144];
  word  Size  [  144];
  word  Ofs   [  144];
  word nName;

  word nData;

  word  Stk   [  128];
  word pStk;

  char  Buff  [  128];


  word  open() is
    inline      0xB0, 0x00;              // mov  AL, 00H
    inline      0xB4, 0x3D;              // mov  AH, 3DH
    inline      0xB2, 0x4A;              // mov  DL, Lo(@@Data+Ofs(Heap[64]=
))
    inline      0xB6, 0xC1;              // mov  DH, Hi(@@Data+Ofs(Heap[64]=
))
    inline      0xCD, 0x21;              // int  21H
    inline      0x8A, 0xD0;              // mov  DL, AL
    inline      0x8A, 0xF4;              // int  DH, AH
  end


  word  create() is
    inline      0xB4, 0x3C;              // mov  AH, 03CH
    inline      0xB1, 0x00;              // mov  CL, 00H
    inline      0xB5, 0x00;              // mov  CH, 00H
    inline      0xB2, 0x50;              // mov  DL, Lo(@@Data+Ofs(Heap[70]=
))
    inline      0xB6, 0xC1;              // mov  DH, Hi(@@Data+Ofs(Heap[70]=
))
    inline      0xCD, 0x21;              // int  21H
    inline      0x8A, 0xD0;              // mov  DL, AL
    inline      0x8A, 0xF4;              // int  DH, AH
  end


  word  read() is
    inline      0xB4, 0x3F;              // mov  AH, 3FH
    inline      0x8A, 0x1E, 0x08, 0xC1;  // mov  BL, [@@DATA+Ofs(hFile)]
    inline      0x8A, 0x3E, 0x09, 0xC1;  // mov  BH, [@@DATA+Ofs(hFile)+1]
    inline      0xB1, 0x00;              // mov  CL, 00H
    inline      0xB5, 0x40;              // mov  CH, 40H
    inline      0xB2, 0x00;              // mov  DL, Lo(@@DATA+Ofs(Text))
    inline      0xB6, 0x41;              // mov  DH, Hi(@@DATA+Ofs(Text))
    inline      0xCD, 0x21;              // int  21H
    inline      0x8A, 0xD0;              // mov  DL, AL
    inline      0x8A, 0xF4;              // int  DH, AH
  end


  word  write() is
    inline      0xB4, 0x40;              // mov  AH, 40H
    inline      0x8A, 0x1E, 0x08, 0xC1;  // mov  BL, [@@DATA+Ofs(hFile)]
    inline      0x8A, 0x3E, 0x09, 0xC1;  // mov  BH, [@@DATA+Ofs(hFile)+1]
    inline      0x8A, 0x0E, 0x06, 0xC1;  // mov  CL, [@@DATA+Ofs(nCode)]
    inline      0x8A, 0x2E, 0x07, 0xC1;  // mov  CH, [@@DATA+Ofs(nCode)+1]
    inline      0xB2, 0x06;              // mov  DL, Lo(@@DATA+Ofs(Code))
    inline      0xB6, 0x81;              // mov  DH, Hi(@@DATA+Ofs(Code))
    inline      0xCD, 0x21;              // int  21H
  end


  word  close() is
    inline      0xB4, 0x3E;              // mov  AH, 3EH
    inline      0x8A, 0x1E, 0x08, 0xC1;  // mov  BL, [@@DATA+Ofs(hFile)]
    inline      0x8A, 0x3E, 0x09, 0xC1;  // mov  BH, [@@DATA+Ofs(hFile)+1]
    inline      0xCD, 0x21;              // int  21H
  end


  char  putc(char C) is
    char        C1:=3DC;
    inline      0x86, 0xD0;              // xchg DL, AL
    inline      0xB4, 0x02;              // mov  AH, 2
    inline      0xCD, 0x21;              // int  21H
  end


  word  halt() is
    inline      0xB0, 0x00;              // mov  AL, 00H
    inline      0xB4, 0x4C;              // mov  AH, 4CH
    inline      0xCD, 0x21;              // int  21H
  end


  word  mul (word A, word B) is
    word  M:=3D0;
    while B >0 do
      word  T  :=3DA;
      word  I  :=3D1;
      while B-I>=3DI do
        T:=3DT+T;
        I:=3DI+I;
      end

      M:=3DM+T;
      B:=3DB-I;
    end

    return M;
  end


  word  div (word A, word B) is
    word  D:=3D0;
    while A>=3DB do
      word  T  :=3DB;
      word  I  :=3D1;
      while A-T>=3DT do
        T:=3DT+T;
        I:=3DI+I;
      end

      A:=3DA-T;
      D:=3DD+I;
    end

    return D;
  end


  word  mod (word A, word B) is
    return A-mul(div(A,B),B);
  end


  word  Init() is
    Heap[ 0]:=3D'0';
    Heap[ 1]:=3D'1';
    Heap[ 2]:=3D'2';
    Heap[ 3]:=3D'3';
    Heap[ 4]:=3D'4';
    Heap[ 5]:=3D'5';
    Heap[ 6]:=3D'6';
    Heap[ 7]:=3D'7';
    Heap[ 8]:=3D'8';
    Heap[ 9]:=3D'9';
    Heap[10]:=3D'A';
    Heap[11]:=3D'B';
    Heap[12]:=3D'C';
    Heap[13]:=3D'D';
    Heap[14]:=3D'E';
    Heap[15]:=3D'F';

    Heap[16]:=3D'c';
    Heap[17]:=3D'h';
    Heap[18]:=3D'a';
    Heap[19]:=3D'r';
    Heap[20]:=3D char(0);

    Heap[21]:=3D'b';
    Heap[22]:=3D'y';
    Heap[23]:=3D't';
    Heap[24]:=3D'e';
    Heap[25]:=3D char(0);

    Heap[26]:=3D'w';
    Heap[27]:=3D'o';
    Heap[28]:=3D'r';
    Heap[29]:=3D'd';
    Heap[30]:=3D char(0);

    Heap[31]:=3D'b';
    Heap[32]:=3D'e';
    Heap[33]:=3D'g';
    Heap[34]:=3D'i';
    Heap[35]:=3D'n';
    Heap[36]:=3D char(0);

    Heap[37]:=3D'i';
    Heap[38]:=3D'f';
    Heap[39]:=3D char(0);

    Heap[40]:=3D'w';
    Heap[41]:=3D'h';
    Heap[42]:=3D'i';
    Heap[43]:=3D'l';
    Heap[44]:=3D'e';
    Heap[45]:=3D char(0);

    Heap[46]:=3D'i';
    Heap[47]:=3D'n';
    Heap[48]:=3D'l';
    Heap[49]:=3D'i';
    Heap[50]:=3D'n';
    Heap[51]:=3D'e';
    Heap[52]:=3D char(0);

    Heap[53]:=3D'r';
    Heap[54]:=3D'e';
    Heap[55]:=3D't';
    Heap[56]:=3D'u';
    Heap[57]:=3D'r';
    Heap[58]:=3D'n';
    Heap[59]:=3D char(0);

    Heap[60]:=3D'e';
    Heap[61]:=3D'n';
    Heap[62]:=3D'd';
    Heap[63]:=3D char(0);

    Heap[64]:=3D'c';
    Heap[65]:=3D'.';
    Heap[66]:=3D'p';
    Heap[67]:=3D'r';
    Heap[68]:=3D'g';
    Heap[69]:=3D char(0);

    Heap[70]:=3D'c';
    Heap[71]:=3D'.';
    Heap[72]:=3D'c';
    Heap[73]:=3D'o';
    Heap[74]:=3D'm';
    Heap[75]:=3D char(0);
    nHeap   :=3D76;

    Name[ 0]:=3D16;
    Cls [ 0]:=3D 1;
    Size[ 0]:=3D 1;

    Name[ 1]:=3D21;
    Cls [ 1]:=3D 1;
    Size[ 1]:=3D 1;

    Name[ 2]:=3D26;
    Cls [ 2]:=3D 1;
    Size[ 2]:=3D 2;
    nName   :=3D 3;

    pStk    :=3D 0;
    nCode   :=3D 0;
    nData   :=3D 16640;
  end


  word  Push(word V) is
    Stk[pStk]:=3DV;
    pStk:=3DpStk+1;
  end


  word  Pop () is
    pStk:=3DpStk-1;
    return Stk[pStk];
  end


  word  Stop() is
    close();

    pStk:=3D0;
    while    nLine!=3D0 do
      Push  (mod(nLine,10));
      nLine:=3Ddiv(nLine,10);
    end

    while pStk!=3D0 do
      putc(char(Pop()+48));
    end

    halt();
  end


  word  val () is
    word E:=3D10;
    word I:=3D 0;
    if Buff[0]=3D'0' then
      if Buff[1]=3D'x' then
        E:=3D16;
        I:=3D 2;
      end
    end

    word N:=3D0;
    while Buff[I]!=3Dchar(0) do
      word K:=3D0;
      while Heap[K]!=3DBuff[I] do
        if K=3DE then
          Stop();
        end

        K:=3DK+1;
      end

      N:=3Dmul(N,E)+K;
      I:=3DI+1;
    end

    return N;
  end


  char  Look() is
    if pText>=3DnText then
      pText :=3D0;
      nText :=3Dread();
      if pText>=3DnText then
        return char(0);
      end
    end

    return     Text[pText];
  end


  char  Read() is
    char   Ch:=3DLook();
    if     Ch =3Dchar(10) then
      nLine  :=3DnLine+1;
    end

    pText    :=3DpText+1;

    return Ch;
  end


  word  isalnum() is
    if 'A'<=3DLook() then
      if Look()<=3D'Z' then
        return 0;
      end
    end

    if 'a'<=3DLook() then
      if Look()<=3D'z' then
        return 0;
      end
    end

    if '0'<=3DLook() then
      if Look()<=3D'9' then
        return 0;
      end
    end

    return     1;
  end


  word  Digraph(char C1, char C2) is
    if Buff[0]=3DC1 then
      if Look()=3DC2 then
        Buff[1]:=3DRead();
        Buff[2]:=3Dchar(0);
      end
    end
  end


  char  Scan() is
    word  pBuff:=3D0;
    while pBuff =3D0 do
      word  sFlag:=3D0;
      while sFlag =3D0 do
        if Look()!=3Dchar( 9) then
          if Look()!=3Dchar(10) then
            if Look()!=3Dchar(13) then
              if Look()!=3Dchar(32) then
                sFlag:=3D1;
              end
            end
          end
        end

        if sFlag=3D0 then
          Read();
        end
      end

      while isalnum()=3D0 do
        Buff[pBuff]:=3D Read();
        pBuff      :=3DpBuff+1;
      end

      if pBuff=3D0 then
        Buff[pBuff]:=3D Read();
        pBuff      :=3DpBuff+1;
      end

      Buff[pBuff]  :=3Dchar(0);

      Digraph('<','=3D');
      Digraph('!','=3D');
      Digraph('>','=3D');
      Digraph(':','=3D');

      if Buff[0]=3D'/' then
        if Look()=3D'/' then
          while Look()!=3Dchar(10) do
            if Read()=3Dchar(0) then
              Stop();
            end
          end

          pBuff:=3D0;
        end
      end
    end
  end


  word  Comp(word pHeap) is
    word pBuff:=3D0;
    while Buff[pBuff]=3DHeap[pHeap] do
      if Buff[pBuff]=3Dchar(0) then
        return 0;
      end

      pHeap:=3DpHeap+1;
      pBuff:=3DpBuff+1;
    end

    return     1;
  end


  word  Find(word fFlag) is
    word  pName:=3D0;
    while pName< nName do
      if Comp(Name[pName])=3D0 then
        return pName;
      end

      pName:=3DpName+1;
    end

    if fFlag=3D0 then
      Stop();
    end

    return     pName;
  end


  byte  Emi1(byte B) is
    Code[nCode]:=3DB;
    nCode:=3DnCode+1;
  end


  word  Emi2(word W) is
    Emi1(mod(W,256));
    Emi1(div(W,256));
  end


  word  Emi3(word P, word W) is
    W:=3DW+256;

    Code[P]  :=3Dmod(W,256);
    Code[P+1]:=3Ddiv(W,256);
  end


  word  MkBX(word I) is
    if Size[Type[I]]=3D2 then
      Emi1(0xEB);            // xchg

      Emi1(0x29);            // dad  H

      Emi1(0x11);            // lxi  D, Val
      Emi2(Ofs[I]);
    end

    if Size[Type[I]]=3D1 then
      Emi1(0x21);            // lxi  H, Val
      Emi2(Ofs[I]);
    end

    Emi1(0x19);              // dad  D
  end


  word  Mov (word E, word D, word I) is
    if Size[I]=3D1 then
      Emi1(0x21);            // lxi  H, Val
      Emi2(Ofs[I]);
    end

    Emi1(E);                 // mov  E, M (mov  M, E)

    if Size[Type[I]]=3D2 then
      Emi1(0x23);            // inx  H

      Emi1(D);               // mov  D, M (mov  M, D)
    end
  end


  word  Assign(word I) is
    if Size[I]>1 then
      Emi1(0xE1);            // pop  H
    end

    Mov (0x73,0x72,I);
  end


  word  Expr() is
    word eFlag:=3D0;
  //if   eFlag =3D0 then
      if '0'<=3DBuff[0] then
        if Buff[0]<=3D'9' then
          Emi1(0x11);        // lxi  D, Val
          Emi2(val());

          eFlag:=3D1;
        end
      end

      if Buff[0]=3D''' then
        Emi1(0x11);          // lxi  D, Val
        Emi2(word(Read()));

        Read();

        eFlag:=3D1;
      end

      if Buff[0]=3D'(' then
        Scan();
        Expr();

        eFlag:=3D1;
      end
  //end

    if   eFlag =3D0 then
      word   I:=3DFind(0);
      if Cls[I]=3D1 then
        Push(I);
        Scan();              // (
        Scan();
        Expr();
        I:=3DPop();
      end

      if Cls[I]=3D2 then
        if Size[I]>1 then
          Push(I);
          Scan();            // [
          Scan();
          Expr();
          I:=3DPop();

          MkBX(I);
        end

        Mov (0x5E,0x56,I);

        if Size[Type[I]]=3D1 then
          Emi1(0x16);        // mvi  D, 0
          Emi1(0x00);
        end
      end

      if Cls[I]=3D3 then
        Scan();              // (

        Push(I);

        Sub[nName]:=3D 0;

        word J:=3DI+1;
        while Sub[J]=3D1 do
          Push(J);
          Scan();
          Expr();
          J:=3DPop();

          Assign(J);

          J:=3DJ+1;
        end

        I:=3DPop();
        if J=3DI+1 then
          Scan();            // )
        end

        Emi1(0xCD);          // call Ofs
        Emi2(Ofs[I]+256);
      end
    end

    Scan();

    byte Op1:=3D0;
    byte Op2:=3D0;
    if Buff[0]=3D'+' then
      Op1:=3D0x83;             // add  E
      Op2:=3D0x8A;             // adc  D
    end

    if Buff[0]=3D'-' then
      Op1:=3D0x93;             // sub  E
      Op2:=3D0x9A;             // sbb  D
    end

    if   Op1!=3D0 then
      Emi1(0xD5);            // push D

      Push(Op1);
      Push(Op2);
      Scan();
      Expr();
      Op2:=3DPop();
      Op1:=3DPop();

      Emi1(0xE1);            // pop  H

      Emi1(0x7D);            // mov  A, L
      Emi1(Op1);             // op1  E
      Emi1(0x5F);            // mov  E, A

      Emi1(0x7C);            // mov  A, H
      Emi1(Op2);             // op2  D
      Emi1(0x57);            // mov  D, A
    end
  end


  word  Jump(byte jCode, word jOfs) is
    if jOfs=3D0 then
      Push(nCode);
    end

    Emi1(jCode);             // jxx  Addr
    Emi2(nCode+jOfs);
  end


  word  Cond() is
    Scan();
    Expr();

    word jType :=3D   0;
    word jOfs1 :=3D   0;
    word jCode2:=3D0xD2;       // jnc
    if Buff[0]=3D'<' then
      jType    :=3D   1;
      if Buff[1]=3D'=3D' then
        jType  :=3D   2;
        jCode2 :=3D0xDA;       // jc
      end
    end

    if Buff[0]=3D'=3D' then
      jType    :=3D   4;
      jCode2   :=3D0xC2;       // jnz
    end

    if Buff[0]=3D'!' then
      jType    :=3D   3;
      jOfs1    :=3D 263;
      jCode2   :=3D0xCA;       // jz
    end

    if Buff[0]=3D'>' then
      jType    :=3D   2;
      if Buff[1]=3D'=3D' then
        jType  :=3D   1;
        jCode2 :=3D0xDA;       // jc
      end
    end

    if jType=3D0 then
      Stop();
    end

    Emi1(0xD5);              // push D

    Scan();
    Expr();

    Emi1(0xE1);              // pop  H

    if jType=3D1 then
      Emi1(0x7D);            // mov  A, L
      Emi1(0x93);            // sub  E
      Emi1(0x7C);            // mov  A, H
      Emi1(0x9A);            // sbb  D
    end

    if jType=3D2 then
      Emi1(0x7B);            // mov  A, E
      Emi1(0x95);            // sub  L
      Emi1(0x7A);            // mov  A, D
      Emi1(0x9C);            // sbb  H
    end

    if jType>=3D3 then
      Emi1(0x7D);            // mov  A, L
      Emi1(0x93);            // sub  E
      Jump(0xC2, jOfs1);     // jnz
      Emi1(0x7C);            // mov  A, H
      Emi1(0x92);            // sub  D
    end

    if jType!=3D4 then
      Push(nCode);
    end

    Jump  (jCode2, 0x00);
  end


  word  Obj (word T) is
    if Cls[T]!=3D1 then
      Stop();
    end

    Name[nName]:=3DnHeap;
    Type[nName]:=3D T;

    Scan();
    if Find(1)<nName then
      Stop();
    end

    word pBuff:=3D0;
    char  Ch  :=3Dchar(1);
    while Ch  !=3Dchar(0) do
      Ch         :=3D Buff[pBuff];
      Heap[nHeap]:=3D Ch;
      nHeap      :=3DnHeap+1;
      pBuff      :=3DpBuff+1;
    end

    Scan();

    return nName;
  end


  char  Var (word Subclass) is
    Cls [nName]:=3D 2;
    Sub [nName]:=3D Subclass;
    Size[nName]:=3D 1;
    Ofs [nName]:=3DnData;

    if Buff[0]=3D'[' then
      if Subclass!=3D0 then
        Stop();
      end

      Scan();
      Size[nName]:=3Dval();
      Scan();                // ]
      Scan();                // ;
    end

    nData      :=3DnData+mul(Size[nName],Size[Type[nName]]);
    nName      :=3DnName+1;

    return Buff[0];
  end


  word  Hide() is
    word  I:=3DPop();
    while I< nName do
      Heap[Name[I]]:=3Dchar(0);
      I :=3DI+1;
    end
  end


  word rFlag;

  word  Ctrl() is
    word cFlag:=3D0;
  //if   cFlag =3D0 then
      if Comp(37)=3D0 then     // if
        Cond();

        Push(nName);

        Scan();
        Ctrl();
        while Comp(60)!=3D0 do // !end
          Ctrl();
        end

        Hide();

        Emi3(Pop()+1,nCode);
        Emi3(Pop()+1,nCode);

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
  //end

    if   cFlag =3D0 then
      if Comp(40)=3D0 then     // while
        Push(nCode);

        Cond();

        Push(nName);

        Scan();
        Ctrl();
        while Comp(60)!=3D0 do // !end
          Ctrl();
        end

        Hide();

        word pExit2:=3DPop();
        word pExit1:=3DPop();
        word pLoop :=3DPop();

        Emi1(0xC3);          // jmp  Ofs
        Emi2(pLoop+256);

        Emi3(pExit1+1,nCode);
        Emi3(pExit2+1,nCode);

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      if Comp(46)=3D0 then     // inline
        Buff[0]:=3D',';
        while Buff[0]=3D',' do
          Scan();
          Emi1(val());       // db   Val

          Scan();
        end

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      if Comp(53)=3D0 then     // return
        Scan();
        Expr();

        Emi1(0xC9);          // ret

        rFlag:=3D0;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      word   I:=3DFind(0);
      if Cls[I]=3D1 then
        word N:=3DObj(I);
        if   Var(2)=3D':' then
          Scan();
          Expr();

          Assign(N);
        end
      end

      if Cls[I]=3D2 then
        if Size[I]>1 then
          Scan();            // [
          Scan();
          Expr();

          MkBX(I);

          Emi1(0xE5);        // push H
        end

        Scan();              // :=3D
        Scan();
        Expr();

        Assign(I);
      end

      if Cls[I]=3D3 then
        Expr();
      end

      rFlag:=3D1;              // 14.05.2006
    end

    Scan();
  end


  word  Func() is
    Scan();
    Ctrl();
    while Comp(60)!=3D0 do     // !end
      Ctrl();
    end

    if rFlag!=3D0 then         // 14.05.2006 // if rFlag=3D0 then
      Emi1(0xC9);            // ret
    end
  end


  begin
    Init();

    hFile:=3Dopen();
    pText:=3D0;
    nText:=3D0;
    nLine:=3D1;

    Emi1(0xC3);              // jmp  ?
    nCode:=3DnCode+2;

    Scan();
    while Comp(31)!=3D0 do     // !begin
      Obj (Find(0));
      char Ch:=3DBuff[0];
      if   Ch =3D'(' then
        Cls [nName]:=3D 3;
        Sub [nName]:=3D 0;
        Ofs [nName]:=3DnCode;
        nName      :=3DnName+1;

        Push(nName);

        Scan();
        if Buff[0]!=3D')' then
          Obj (Find(0));
          while Var(1)=3D',' do
            Scan();
            Obj (Find(0));
          end
        end

        Scan();              // is
        Func();
        Hide();
      end

      if   Ch!=3D'(' then
        Var(0);
      end

      Scan();
    end

    Emi3 (1,nCode);
    Func ();

    while mod(nCode,128)!=3D0 do
      Emi1(0x1A);
    end

    close();

    hFile:=3Dcreate();
    write();
    close();
  end
</xmp>
<p>
CP/M version are based on code listed above but has another I/O functions
and some other differnces:
</p><p>
</p><xmp>
  byte  FCB   [   36];
  byte  DMA   [  128];

  word pText;
  word nText;
  word nLine;

  byte  Code  [16384];
  word nCode;

  char  Heap  [ 2048];
  word nHeap;

  word  Name  [  144];
  word  Cls   [  144];
  word  Sub   [  144];
  word  Type  [  144];
  word  Size  [  144];
  word  Ofs   [  144];
  word nName;

  word nData;

  word  Stk   [  128];
  word pStk;

  char  Buff  [  128];


  word  setdma() is
    inline 0x0E, 0x1A;       // mvi  C, 1AH
    inline 0x11, 0x24, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  open() is
    inline 0x0E, 0x0F;       // mvi  C, 0FH
    inline 0x11, 0x00, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  create() is
    inline 0x0E, 0x16;       // mvi  C, 16H
    inline 0x11, 0x00, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  read() is
    inline 0x0E, 0x14;       // mvi  C, 14H
    inline 0x11, 0x00, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
    inline 0x5F;             // mov  E, A
    inline 0x16, 0x00;       // mvi  D, 0
  end


  word  write() is
    inline 0x0E, 0x15;       // mvi  C, 15H
    inline 0x11, 0x00, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  close() is
    inline 0x0E, 0x10;       // mvi  C, 10H
    inline 0x11, 0x00, 0x41; // lxi  D
    inline 0xCD, 0x05, 0x00; // call 5
  end


  char  putc(char C) is
    inline 0x0E, 0x02;       // mvi  C, 2
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  halt() is
    inline 0x0E, 0x00;       // mvi  C, 00H
    inline 0xCD, 0x05, 0x00; // call 5
  end


  word  mul (word A, word B) is
    word  M:=3D0;
    while B >0 do
      word  T  :=3DA;
      word  I  :=3D1;
      while B-I>=3DI do
        T:=3DT+T;
        I:=3DI+I;
      end

      M:=3DM+T;
      B:=3DB-I;
    end

    return M;
  end


  word  div (word A, word B) is
    word  D:=3D0;
    while A>=3DB do
      word  T  :=3DB;
      word  I  :=3D1;
      while A-T>=3DT do
        T:=3DT+T;
        I:=3DI+I;
      end

      A:=3DA-T;
      D:=3DD+I;
    end

    return D;
  end


  word  mod (word A, word B) is
    return A-mul(div(A,B),B);
  end


  word  Init() is
    Heap[ 0]:=3D'0';
    Heap[ 1]:=3D'1';
    Heap[ 2]:=3D'2';
    Heap[ 3]:=3D'3';
    Heap[ 4]:=3D'4';
    Heap[ 5]:=3D'5';
    Heap[ 6]:=3D'6';
    Heap[ 7]:=3D'7';
    Heap[ 8]:=3D'8';
    Heap[ 9]:=3D'9';
    Heap[10]:=3D'A';
    Heap[11]:=3D'B';
    Heap[12]:=3D'C';
    Heap[13]:=3D'D';
    Heap[14]:=3D'E';
    Heap[15]:=3D'F';

    Heap[16]:=3D'c';
    Heap[17]:=3D'h';
    Heap[18]:=3D'a';
    Heap[19]:=3D'r';
    Heap[20]:=3D char(0);

    Heap[21]:=3D'b';
    Heap[22]:=3D'y';
    Heap[23]:=3D't';
    Heap[24]:=3D'e';
    Heap[25]:=3D char(0);

    Heap[26]:=3D'w';
    Heap[27]:=3D'o';
    Heap[28]:=3D'r';
    Heap[29]:=3D'd';
    Heap[30]:=3D char(0);

    Heap[31]:=3D'b';
    Heap[32]:=3D'e';
    Heap[33]:=3D'g';
    Heap[34]:=3D'i';
    Heap[35]:=3D'n';
    Heap[36]:=3D char(0);

    Heap[37]:=3D'i';
    Heap[38]:=3D'f';
    Heap[39]:=3D char(0);

    Heap[40]:=3D'w';
    Heap[41]:=3D'h';
    Heap[42]:=3D'i';
    Heap[43]:=3D'l';
    Heap[44]:=3D'e';
    Heap[45]:=3D char(0);

    Heap[46]:=3D'i';
    Heap[47]:=3D'n';
    Heap[48]:=3D'l';
    Heap[49]:=3D'i';
    Heap[50]:=3D'n';
    Heap[51]:=3D'e';
    Heap[52]:=3D char(0);

    Heap[53]:=3D'r';
    Heap[54]:=3D'e';
    Heap[55]:=3D't';
    Heap[56]:=3D'u';
    Heap[57]:=3D'r';
    Heap[58]:=3D'n';
    Heap[59]:=3D char(0);

    Heap[60]:=3D'e';
    Heap[61]:=3D'n';
    Heap[62]:=3D'd';
    Heap[63]:=3D char(0);
    nHeap   :=3D64;

    Name[ 0]:=3D16;
    Cls [ 0]:=3D 1;
    Size[ 0]:=3D 1;

    Name[ 1]:=3D21;
    Cls [ 1]:=3D 1;
    Size[ 1]:=3D 1;

    Name[ 2]:=3D26;
    Cls [ 2]:=3D 1;
    Size[ 2]:=3D 2;
    nName   :=3D 3;

    pStk    :=3D 0;
    nCode   :=3D 0;
    nData   :=3D 16640;
  end


  word  Push(word V) is
    Stk[pStk]:=3DV;
    pStk:=3DpStk+1;
  end


  word  Pop () is
    pStk:=3DpStk-1;
    return Stk[pStk];
  end


  word  Stop() is
    close();

    pStk:=3D0;
    while    nLine!=3D0 do
      Push  (mod(nLine,10));
      nLine:=3Ddiv(nLine,10);
    end

    while pStk!=3D0 do
      putc(char(Pop()+48));
    end

    halt();
  end


  word  val () is
    word E:=3D10;
    word I:=3D 0;
    if Buff[0]=3D'0' then
      if Buff[1]=3D'x' then
        E:=3D16;
        I:=3D 2;
      end
    end

    word N:=3D0;
    while Buff[I]!=3Dchar(0) do
      word K:=3D0;
      while Heap[K]!=3DBuff[I] do
        if K=3DE then
          Stop();
        end

        K:=3DK+1;
      end

      N:=3Dmul(N,E)+K;
      I:=3DI+1;
    end

    return N;
  end


  char  Look() is
    if pText>=3DnText then
      if read()!=3D0 then
        return char(0);
      end

      pText:=3D  0;
      nText:=3D128;
    end

    return     char(DMA[pText]);
  end


  char  Read() is
    char   Ch:=3DLook();
    if     Ch =3Dchar(10) then
      nLine  :=3DnLine+1;
    end

    pText    :=3DpText+1;

    return Ch;
  end


  word  isalnum() is
    if 'A'<=3DLook() then
      if Look()<=3D'Z' then
        return 0;
      end
    end

    if 'a'<=3DLook() then
      if Look()<=3D'z' then
        return 0;
      end
    end

    if '0'<=3DLook() then
      if Look()<=3D'9' then
        return 0;
      end
    end

    return     1;
  end


  word  Digraph(char C1, char C2) is
    if Buff[0]=3DC1 then
      if Look()=3DC2 then
        Buff[1]:=3DRead();
        Buff[2]:=3Dchar(0);
      end
    end
  end


  char  Scan() is
    word  pBuff:=3D0;
    while pBuff =3D0 do
      word  sFlag:=3D0;
      while sFlag =3D0 do
        if Look()!=3Dchar( 9) then
          if Look()!=3Dchar(10) then
            if Look()!=3Dchar(13) then
              if Look()!=3Dchar(32) then
                sFlag:=3D1;
              end
            end
          end
        end

        if sFlag=3D0 then
          Read();
        end
      end

      while isalnum()=3D0 do
        Buff[pBuff]:=3D Read();
        pBuff      :=3DpBuff+1;
      end

      if pBuff=3D0 then
        Buff[pBuff]:=3D Read();
        pBuff      :=3DpBuff+1;
      end

      Buff[pBuff]  :=3Dchar(0);

      Digraph('<','=3D');
      Digraph('!','=3D');
      Digraph('>','=3D');
      Digraph(':','=3D');

      if Buff[0]=3D'/' then
        if Look()=3D'/' then
          while Look()!=3Dchar(10) do
            if Read()=3Dchar(0) then
              Stop();
            end
          end

          pBuff:=3D0;
        end
      end
    end
  end


  word  Comp(word pHeap) is
    word pBuff:=3D0;
    while Buff[pBuff]=3DHeap[pHeap] do
      if Buff[pBuff]=3Dchar(0) then
        return 0;
      end

      pHeap:=3DpHeap+1;
      pBuff:=3DpBuff+1;
    end

    return     1;
  end


  word  Find(word fFlag) is
    word  pName:=3D0;
    while pName< nName do
      if Comp(Name[pName])=3D0 then
        return pName;
      end

      pName:=3DpName+1;
    end

    if fFlag=3D0 then
      Stop();
    end

    return     pName;
  end


  byte  Emi1(byte B) is
    Code[nCode]:=3DB;
    nCode:=3DnCode+1;
  end


  word  Emi2(word W) is
    Emi1(mod(W,256));
    Emi1(div(W,256));
  end


  word  Emi3(word P, word W) is
    W:=3DW+256;

    Code[P]  :=3Dmod(W,256);
    Code[P+1]:=3Ddiv(W,256);
  end


  word  MkBX(word I) is
    if Size[Type[I]]=3D2 then
      Emi1(0xEB);            // xchg

      Emi1(0x29);            // dad  H

      Emi1(0x11);            // lxi  D, Val
      Emi2(Ofs[I]);
    end

    if Size[Type[I]]=3D1 then
      Emi1(0x21);            // lxi  H, Val
      Emi2(Ofs[I]);
    end

    Emi1(0x19);              // dad  D
  end


  word  Mov (word E, word D, word I) is
    if Size[I]=3D1 then
      Emi1(0x21);            // lxi  H, Val
      Emi2(Ofs[I]);
    end

    Emi1(E);                 // mov  E, M (mov  M, E)

    if Size[Type[I]]=3D2 then
      Emi1(0x23);            // inx  H

      Emi1(D);               // mov  D, M (mov  M, D)
    end
  end


  word  Assign(word I) is
    if Size[I]>1 then
      Emi1(0xE1);            // pop  H
    end

    Mov (0x73,0x72,I);
  end


  word  Expr() is
    word eFlag:=3D0;
  //if   eFlag =3D0 then
      if '0'<=3DBuff[0] then
        if Buff[0]<=3D'9' then
          Emi1(0x11);        // lxi  D, Val
          Emi2(val());

          eFlag:=3D1;
        end
      end

      if Buff[0]=3D''' then
        Emi1(0x11);          // lxi  D, Val
        Emi2(word(Read()));

        Read();

        eFlag:=3D1;
      end

      if Buff[0]=3D'(' then
        Scan();
        Expr();

        eFlag:=3D1;
      end
  //end

    if   eFlag =3D0 then
      word   I:=3DFind(0);
      if Cls[I]=3D1 then
        Push(I);
        Scan();              // (
        Scan();
        Expr();
        I:=3DPop();
      end

      if Cls[I]=3D2 then
        if Size[I]>1 then
          Push(I);
          Scan();            // [
          Scan();
          Expr();
          I:=3DPop();

          MkBX(I);
        end

        Mov (0x5E,0x56,I);

        if Size[Type[I]]=3D1 then
          Emi1(0x16);        // mvi  D, 0
          Emi1(0x00);
        end
      end

      if Cls[I]=3D3 then
        Scan();              // (

        Push(I);

        Sub[nName]:=3D 0;

        word J:=3DI+1;
        while Sub[J]=3D1 do
          Push(J);
          Scan();
          Expr();
          J:=3DPop();

          Assign(J);

          J:=3DJ+1;
        end

        I:=3DPop();
        if J=3DI+1 then
          Scan();            // )
        end

        Emi1(0xCD);          // call Ofs
        Emi2(Ofs[I]+256);
      end
    end

    Scan();

    byte Op1:=3D0;
    byte Op2:=3D0;
    if Buff[0]=3D'+' then
      Op1:=3D0x83;             // add  E
      Op2:=3D0x8A;             // adc  D
    end

    if Buff[0]=3D'-' then
      Op1:=3D0x93;             // sub  E
      Op2:=3D0x9A;             // sbb  D
    end

    if   Op1!=3D0 then
      Emi1(0xD5);            // push D

      Push(Op1);
      Push(Op2);
      Scan();
      Expr();
      Op2:=3DPop();
      Op1:=3DPop();

      Emi1(0xE1);            // pop  H

      Emi1(0x7D);            // mov  A, L
      Emi1(Op1);             // op1  E
      Emi1(0x5F);            // mov  E, A

      Emi1(0x7C);            // mov  A, H
      Emi1(Op2);             // op2  D
      Emi1(0x57);            // mov  D, A
    end
  end


  word  Jump(byte jCode, word jOfs) is
    if jOfs=3D0 then
      Push(nCode);
    end

    Emi1(jCode);             // jxx  Addr
    Emi2(nCode+jOfs);
  end


  word  Cond() is
    Scan();
    Expr();

    word jType :=3D   0;
    word jOfs1 :=3D   0;
    word jCode2:=3D0xD2;       // jnc
    if Buff[0]=3D'<' then
      jType    :=3D   1;
      if Buff[1]=3D'=3D' then
        jType  :=3D   2;
        jCode2 :=3D0xDA;       // jc
      end
    end

    if Buff[0]=3D'=3D' then
      jType    :=3D   4;
      jCode2   :=3D0xC2;       // jnz
    end

    if Buff[0]=3D'!' then
      jType    :=3D   3;
      jOfs1    :=3D 263;
      jCode2   :=3D0xCA;       // jz
    end

    if Buff[0]=3D'>' then
      jType    :=3D   2;
      if Buff[1]=3D'=3D' then
        jType  :=3D   1;
        jCode2 :=3D0xDA;       // jc
      end
    end

    if jType=3D0 then
      Stop();
    end

    Emi1(0xD5);              // push D

    Scan();
    Expr();

    Emi1(0xE1);              // pop  H

    if jType=3D1 then
      Emi1(0x7D);            // mov  A, L
      Emi1(0x93);            // sub  E
      Emi1(0x7C);            // mov  A, H
      Emi1(0x9A);            // sbb  D
    end

    if jType=3D2 then
      Emi1(0x7B);            // mov  A, E
      Emi1(0x95);            // sub  L
      Emi1(0x7A);            // mov  A, D
      Emi1(0x9C);            // sbb  H
    end

    if jType>=3D3 then
      Emi1(0x7D);            // mov  A, L
      Emi1(0x93);            // sub  E
      Jump(0xC2, jOfs1);     // jnz
      Emi1(0x7C);            // mov  A, H
      Emi1(0x92);            // sub  D
    end

    if jType!=3D4 then
      Push(nCode);
    end

    Jump  (jCode2, 0x00);
  end


  word  Obj (word T) is
    if Cls[T]!=3D1 then
      Stop();
    end

    Name[nName]:=3DnHeap;
    Type[nName]:=3D T;

    Scan();
    if Find(1)<nName then
      Stop();
    end

    word pBuff:=3D0;
    char  Ch  :=3Dchar(1);
    while Ch  !=3Dchar(0) do
      Ch         :=3D Buff[pBuff];
      Heap[nHeap]:=3D Ch;
      nHeap      :=3DnHeap+1;
      pBuff      :=3DpBuff+1;
    end

    Scan();

    return nName;
  end


  char  Var (word Subclass) is
    Cls [nName]:=3D 2;
    Sub [nName]:=3D Subclass;
    Size[nName]:=3D 1;
    Ofs [nName]:=3DnData;

    if Buff[0]=3D'[' then
      if Subclass!=3D0 then
        Stop();
      end

      Scan();
      Size[nName]:=3Dval();
      Scan();                // ]
      Scan();                // ;
    end

    nData      :=3DnData+mul(Size[nName],Size[Type[nName]]);
    nName      :=3DnName+1;

    return Buff[0];
  end


  word  Hide() is
    word  I:=3DPop();
    while I< nName do
      Heap[Name[I]]:=3Dchar(0);
      I :=3DI+1;
    end
  end


  word rFlag;

  word  Ctrl() is
    word cFlag:=3D0;
  //if   cFlag =3D0 then
      if Comp(37)=3D0 then     // if
        Cond();

        Push(nName);

        Scan();
        Ctrl();
        while Comp(60)!=3D0 do // !end
          Ctrl();
        end

        Hide();

        Emi3(Pop()+1,nCode);
        Emi3(Pop()+1,nCode);

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
  //end

    if   cFlag =3D0 then
      if Comp(40)=3D0 then     // while
        Push(nCode);

        Cond();

        Push(nName);

        Scan();
        Ctrl();
        while Comp(60)!=3D0 do // !end
          Ctrl();
        end

        Hide();

        word pExit2:=3DPop();
        word pExit1:=3DPop();
        word pLoop :=3DPop();

        Emi1(0xC3);          // jmp  Ofs
        Emi2(pLoop+256);

        Emi3(pExit1+1,nCode);
        Emi3(pExit2+1,nCode);

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      if Comp(46)=3D0 then     // inline
        Buff[0]:=3D',';
        while Buff[0]=3D',' do
          Scan();
          Emi1(val());       // db   Val

          Scan();
        end

        rFlag:=3D1;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      if Comp(53)=3D0 then     // return
        Scan();
        Expr();

        Emi1(0xC9);          // ret

        rFlag:=3D0;            // 14.05.2006
        cFlag:=3D1;
      end
    end

    if   cFlag =3D0 then
      word   I:=3DFind(0);
      if Cls[I]=3D1 then
        word N:=3DObj(I);
        if   Var(2)=3D':' then
          Scan();
          Expr();

          Assign(N);
        end
      end

      if Cls[I]=3D2 then
        if Size[I]>1 then
          Scan();            // [
          Scan();
          Expr();

          MkBX(I);

          Emi1(0xE5);        // push H
        end

        Scan();              // :=3D
        Scan();
        Expr();

        Assign(I);
      end

      if Cls[I]=3D3 then
        Expr();
      end

      rFlag:=3D1;              // 14.05.2006
    end

    Scan();
  end


  word  Func() is
    Scan();
    Ctrl();
    while Comp(60)!=3D0 do     // !end
      Ctrl();
    end

    if rFlag!=3D0 then         // 14.05.2006 // if rFlag=3D0 then
      Emi1(0xC9);            // ret
    end
  end


  byte InitFCB() is
    FCB[ 0]:=3D0x00;
    FCB[ 1]:=3Dbyte('C');

    word  I:=3D 2;
    while I< 12 do
      FCB[I]:=3Dbyte(' ');
      I:=3D I+1;
    end

    while I< 36 do
      FCB[I]:=3D0x00;
      I:=3D I+1;
    end
  end


  begin
    setdma();

    Init();

    InitFCB();

    FCB[ 9]:=3Dbyte('P');
    FCB[10]:=3Dbyte('R');
    FCB[11]:=3Dbyte('G');

    open();

    pText:=3D0;
    nText:=3D0;
    nLine:=3D1;

    Emi1(0xC3);              // jmp  ?
    nCode:=3DnCode+2;

    Scan();
    while Comp(31)!=3D0 do     // !begin
      Obj (Find(0));
      char Ch:=3DBuff[0];
      if   Ch =3D'(' then
        Cls [nName]:=3D 3;
        Sub [nName]:=3D 0;
        Ofs [nName]:=3DnCode;
        nName      :=3DnName+1;

        Push(nName);

        Scan();
        if Buff[0]!=3D')' then
          Obj (Find(0));
          while Var(1)=3D',' do
            Scan();
            Obj (Find(0));
          end
        end

        Scan();              // is
        Func();
        Hide();
      end

      if   Ch!=3D'(' then
        Var(0);
      end

      Scan();
    end

    Emi3 (1,nCode);
    Func ();

    while mod(nCode,128)!=3D0 do
      Emi1(0x1A);
    end

    close();

    InitFCB();

    FCB[ 9]:=3Dbyte('C');
    FCB[10]:=3Dbyte('O');
    FCB[11]:=3Dbyte('M');

    create();

    word  I:=3D0;
    word  J:=3D0;
    while I<nCode do
      if J>=3D128 then
        write();
        J:=3D0;
      end

      DMA[J]:=3DCode[I];

      J:=3DJ+1;
      I:=3DI+1;
    end

    write();
    close();
  end
</xmp>
<p>
</p><center>
<!-- SpyLOG v2 f:1211 -->
<a href=3D"http://u715.56.spylog.com/cnt?f=3D3&amp;p=3D1&amp;rn=3D0.5192603=
978319756" target=3D"_blank"><img src=3D"http://u715.56.spylog.com/cnt?p=3D=
1&amp;rn=3D0.5192603978319756&amp;r1=3Dhttps%3A//www.avhohlov.narod.ru/p182=
0ru.htm&amp;r=3Dhttps%3A//www.avhohlov.narod.ru/p1820ru.htm&amp;pg=3Dhttps%=
3A//www.avhohlov.narod.ru/p1820en.htm" border=3D"0" width=3D"88" height=3D"=
31" alt=3D"SpyLOG" n653uzb01=3D""></a>
<!-- SpyLOG  -->
<!-- HotLog -->



<a href=3D"http://click.hotlog.ru/?91733" target=3D"_top"><img src=3D"http:=
//hit5.hotlog.ru/cgi-bin/hotlog/count?0.2483049294452322&amp;s=3D91733&amp;=
im=3D33&amp;r=3Dhttps%3A//www.avhohlov.narod.ru/p1820ru.htm&amp;pg=3Dhttps%=
3A//www.avhohlov.narod.ru/p1820en.htm&amp;c=3DY&amp;j=3DN&amp;wh=3D1536x864=
&amp;px=3D24&amp;js=3D1.3&amp;" border=3D"0" width=3D"88" height=3D"31" alt=
=3D"HotLog" n653uzb01=3D""></a>

<!-- /HotLog -->
<!--Rating@Mail.ru COUNTER--><a href=3D"http://top.mail.ru/jump?from=3D7473=
9" target=3D"_top"><img src=3D"http://top.list.ru/counter?id=3D74739;t=3D23=
9;js=3D13;r=3Dhttps%3A//www.avhohlov.narod.ru/p1820ru.htm;j=3Dfalse;s=3D153=
6*864;d=3D24;rand=3D0.1773402197734424" alt=3D"=D0=A0=D0=B5=D0=B9=D1=82=D0=
=B8=D0=BD=D0=B3@Mail.ru" border=3D"0" height=3D"31" width=3D"88" n653uzb01=
=3D""></a><!-- <noscript><a
target=3D_top href=3D"http://top.mail.ru/jump?from=3D74739"><img
src=3D"http://top.list.ru/counter?js=3Dna;id=3D74739;t=3D239"
border=3D0 height=3D31 width=3D88
alt=3D"=D0=A0=D0=B5=D0=B9=D1=82=D0=B8=D0=BD=D0=B3@Mail.ru"></a></noscript><=
script language=3D"JavaScript"><!--
if(js>11)d.write('--'+'>')//--><!--/COUNTER-->
</center>
<!-- copyright (t2) --><div align=3D"center">=D0=A1=D0=B0=D0=B9=D1=82 =D1=
=81=D0=BE=D0=B7=D0=B4=D0=B0=D0=BD =D0=B2 =D1=81=D0=B8=D1=81=D1=82=D0=B5=D0=
=BC=D0=B5 <a href=3D"http://www.ucoz.ru/" title=3D"=D0=A1=D0=BE=D0=B7=D0=B4=
=D0=B0=D1=82=D1=8C =D1=81=D0=B0=D0=B9=D1=82 =D0=B1=D0=B5=D1=81=D0=BF=D0=BB=
=D0=B0=D1=82=D0=BD=D0=BE">uCoz</a><br></div><!-- /copyright -->



</body></html>
------MultipartBoundary--tPmwumyDLue6sGvbnBmHxGouL6wPfBB98PVhjOoSiw------
